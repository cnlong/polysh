diff --git a/.travis.yml b/.travis.yml
index ddb80d6..dd52f18 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -4,7 +4,6 @@
 sudo: true
 language: python
 python:
-  - "3.4"
   - "3.5"
   - "3.6"
 install:
diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 277f4b2..3d41ff4 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -1,3 +1,7 @@
+Version 0.11
+    * Add Python 3.5 style type hints
+    * Drop Python 3.4 support
+
 Version 0.10
     * Stop overwriting the users shell to support aliases and other shells such as zsh
 
diff --git a/polysh/buffered_dispatcher.py b/polysh/buffered_dispatcher.py
index 6a2e152..4a036ba 100644
--- a/polysh/buffered_dispatcher.py
+++ b/polysh/buffered_dispatcher.py
@@ -29,16 +29,16 @@ class BufferedDispatcher(asyncore.file_dispatcher):
     # 1 MiB should be enough for everybody
     MAX_BUFFER_SIZE = 1 * 1024 * 1024
 
-    def __init__(self, fd):
+    def __init__(self, fd: int) -> None:
         asyncore.file_dispatcher.__init__(self, fd)
         self.fd = fd
         self.read_buffer = b''
         self.write_buffer = b''
 
-    def handle_read(self):
+    def handle_read(self) -> None:
         self._handle_read_chunk()
 
-    def _handle_read_chunk(self):
+    def _handle_read_chunk(self) -> bytes:
         """Some data can be read"""
         new_data = b''
         buffer_length = len(self.read_buffer)
@@ -70,15 +70,15 @@ class BufferedDispatcher(asyncore.file_dispatcher):
             self.read_buffer += new_data
         return new_data
 
-    def readable(self):
+    def readable(self) -> bool:
         """No need to ask data if our buffer is already full"""
         return len(self.read_buffer) < self.MAX_BUFFER_SIZE
 
-    def writable(self):
+    def writable(self) -> bool:
         """Do we have something to write?"""
         return self.write_buffer != b''
 
-    def dispatch_write(self, buf):
+    def dispatch_write(self, buf: bytes) -> bool:
         """Augment the buffer with stuff to write when possible"""
         self.write_buffer += buf
         if len(self.write_buffer) > self.MAX_BUFFER_SIZE:
diff --git a/polysh/callbacks.py b/polysh/callbacks.py
index 6eb654b..31b280e 100644
--- a/polysh/callbacks.py
+++ b/polysh/callbacks.py
@@ -29,14 +29,16 @@ Copyright (c) 2018 InnoGames GmbH
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 import random
+from typing import Callable
+from typing import Tuple
 
 DIGITS_LETTERS = list(map(str, list(range(10)))) + \
     list(map(chr, list(range(ord('a'), ord('z') + 1)))) + \
     list(map(chr, list(range(ord('A'), ord('Z') + 1))))
 
 
-def random_string(length):
-    def random_char():
+def random_string(length: int) -> str:
+    def random_char() -> str:
         return DIGITS_LETTERS[random.randint(0, len(DIGITS_LETTERS) - 1)]
     return ''.join([random_char() for i in range(length)])
 
@@ -48,7 +50,7 @@ NR_GENERATED_TRIGGERS = 0
 CALLBACKS = {}
 
 
-def add(name, function, repeat):
+def add(name: bytes, function: Callable, repeat: bool) -> Tuple[bytes, bytes]:
     name = name.replace(b'/', b'_')
     global NR_GENERATED_TRIGGERS
     nr = NR_GENERATED_TRIGGERS
@@ -61,12 +63,11 @@ def add(name, function, repeat):
     return trigger1, trigger2
 
 
-def any_in(data):
+def any_in(data: bytes) -> bool:
     return COMMON_PREFIX in data
 
 
-def process(line):
-    assert isinstance(line, bytes)
+def process(line: bytes) -> bool:
     start = line.find(COMMON_PREFIX)
     if start < 0:
         return False
diff --git a/polysh/completion.py b/polysh/completion.py
index 5f3f209..36892bf 100644
--- a/polysh/completion.py
+++ b/polysh/completion.py
@@ -19,13 +19,14 @@ Copyright (c) 2018 InnoGames GmbH
 import glob
 import os
 import readline
+from typing import Optional, List, Set
 
 from polysh.control_commands_helpers import complete_control_command
 from polysh.control_commands_helpers import expand_local_path
 
 
-def complete_local_path(path):
-    def get_suffix(p):
+def complete_local_path(path: str) -> List[str]:
+    def get_suffix(p: str) -> str:
         if os.path.isdir(p):
             return '/'
         return ''
@@ -34,8 +35,8 @@ def complete_local_path(path):
     return paths
 
 
-def remove_dupes(words):
-    added = set()
+def remove_dupes(words: List[str]) -> List[str]:
+    added = set()  # type: Set[str]
     results = list()
     for w in words:
         stripped = w.rstrip('/ ')
@@ -45,8 +46,8 @@ def remove_dupes(words):
     return results
 
 
-def read_commands_in_path():
-    commands = set()
+def read_commands_in_path() -> List[str]:
+    commands = set()  # type: Set[str]
 
     for path in (os.getenv('PATH') or '').split(':'):
         if path:
@@ -61,7 +62,7 @@ def read_commands_in_path():
 
 # All the words that have been typed in polysh. Used by the completion
 # mechanism.
-history_words = set()
+history_words = set()  # type: Set[str]
 
 # When listing possible completions, the complete() function is called with
 # an increasing state parameter until it returns None. Cache the completion
@@ -72,7 +73,7 @@ completion_results = None
 user_commands_in_path = read_commands_in_path()
 
 
-def complete(text, state):
+def complete(text: str, state: int) -> Optional[str]:
     """On tab press, return the next possible completion"""
     global completion_results
     if state == 0:
@@ -107,18 +108,18 @@ def complete(text, state):
     return None
 
 
-def add_to_history(cmd):
+def add_to_history(cmd: str) -> None:
     if len(history_words) < 10000:
         history_words.update(w for w in cmd.split() if len(w) > 1)
 
 
-def remove_last_history_item():
+def remove_last_history_item() -> None:
     """The user just typed a password..."""
     last = readline.get_current_history_length() - 1
     readline.remove_history_item(last)
 
 
-def install_completion_handler():
+def install_completion_handler() -> None:
     readline.set_completer(complete)
     readline.parse_and_bind('tab: complete')
     readline.set_completer_delims(' \t\n')
diff --git a/polysh/console.py b/polysh/console.py
index c2ea14c..752b5ba 100644
--- a/polysh/console.py
+++ b/polysh/console.py
@@ -18,16 +18,16 @@ Copyright (c) 2018 InnoGames GmbH
 
 import errno
 import os
+from typing import Optional
 
 # We remember the length of the last printed status in order to
 # clear it with ' ' characters
 last_status_length = None
 
 
-def safe_write(buf):
+def safe_write(buf: bytes) -> None:
     """We can get a SIGWINCH when printing, which will cause write to raise
     an EINTR. That's not a reason to stop printing."""
-    assert isinstance(buf, bytes)
     while True:
         try:
             os.write(1, buf)
@@ -37,11 +37,8 @@ def safe_write(buf):
                 raise
 
 
-def console_output(msg, logging_msg=None):
+def console_output(msg: bytes, logging_msg: Optional[bytes] = None) -> None:
     """Use instead of print, to clear the status information before printing"""
-    assert isinstance(msg, bytes)
-    assert isinstance(logging_msg, bytes) or logging_msg is None
-
     from polysh import remote_dispatcher
 
     remote_dispatcher.log(logging_msg or msg)
@@ -56,7 +53,7 @@ def console_output(msg, logging_msg=None):
     safe_write(msg)
 
 
-def set_last_status_length(length):
+def set_last_status_length(length: int) -> None:
     """The length of the prefix to be cleared when printing something"""
     global last_status_length
     last_status_length = length
diff --git a/polysh/control_commands.py b/polysh/control_commands.py
index 285cfc3..2e1170e 100644
--- a/polysh/control_commands.py
+++ b/polysh/control_commands.py
@@ -21,6 +21,7 @@ Copyright (c) 2018 InnoGames GmbH
 import asyncore
 import os
 import shlex
+from typing import List
 
 from polysh.control_commands_helpers import (
     complete_shells,
@@ -35,32 +36,32 @@ from polysh import remote_dispatcher
 from polysh import stdin
 
 
-def complete_list(line, text):
+def complete_list(line: str, text: str) -> List[str]:
     return complete_shells(line, text)
 
 
-def do_list(command):
+def do_list(command: str) -> None:
     instances = [i.get_info() for i in selected_shells(command)]
     flat_instances = dispatchers.format_info(instances)
     console_output(b''.join(flat_instances))
 
 
-def do_quit(command):
+def do_quit(command: str) -> None:
     raise asyncore.ExitNow(0)
 
 
-def complete_chdir(line, text):
+def complete_chdir(line: str, text: str) -> List[str]:
     return list(filter(os.path.isdir, complete_local_path(text)))
 
 
-def do_chdir(command):
+def do_chdir(command: str) -> None:
     try:
         os.chdir(expand_local_path(command.strip()))
     except OSError as e:
         console_output('{}\n'.format(str(e)).encode())
 
 
-def complete_send_ctrl(line, text):
+def complete_send_ctrl(line: str, text: str) -> List[str]:
     if len(line[:-1].split()) >= 2:
         # Control letter already given in command line
         return complete_shells(line, text, lambda i: i.enabled)
@@ -69,7 +70,7 @@ def complete_send_ctrl(line, text):
     return ['c ', 'd ', 'z ']
 
 
-def do_send_ctrl(command):
+def do_send_ctrl(command: str) -> None:
     split = command.split()
     if not split:
         console_output(b'Expected at least a letter\n')
@@ -85,39 +86,40 @@ def do_send_ctrl(command):
             i.dispatch_write(control_letter.encode())
 
 
-def complete_reset_prompt(line, text):
+def complete_reset_prompt(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i: i.enabled)
 
 
-def do_reset_prompt(command):
+def do_reset_prompt(command: str) -> None:
     for i in selected_shells(command):
         i.dispatch_command(i.init_string)
 
 
-def complete_enable(line, text):
+def complete_enable(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i:
                            i.state != remote_dispatcher.STATE_DEAD)
 
 
-def do_enable(command):
+def do_enable(command: str) -> None:
     toggle_shells(command, True)
 
 
-def complete_disable(line, text):
+def complete_disable(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i:
                            i.state != remote_dispatcher.STATE_DEAD)
 
 
-def do_disable(command):
+
+def do_disable(command: str) -> None:
     toggle_shells(command, False)
 
 
-def complete_reconnect(line, text):
+def complete_reconnect(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i:
                            i.state == remote_dispatcher.STATE_DEAD)
 
 
-def do_reconnect(command):
+def do_reconnect(command: str) -> None:
     selec = selected_shells(command)
     to_reconnect = [i for i in selec if i.state ==
                     remote_dispatcher.STATE_DEAD]
@@ -129,15 +131,15 @@ def do_reconnect(command):
     dispatchers.create_remote_dispatchers(hosts)
 
 
-def do_add(command):
+def do_add(command: str) -> None:
     dispatchers.create_remote_dispatchers(command.split())
 
 
-def complete_purge(line, text):
+def complete_purge(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i: not i.enabled)
 
 
-def do_purge(command):
+def do_purge(command: str) -> None:
     to_delete = []
     for i in selected_shells(command):
         if not i.enabled:
@@ -147,13 +149,13 @@ def do_purge(command):
         i.close()
 
 
-def do_rename(command):
+def do_rename(command: str) -> None:
     for i in dispatchers.all_instances():
         if i.enabled:
             i.rename(command.encode())
 
 
-def do_hide_password(command):
+def do_hide_password(command: str) -> None:
     warned = False
     for i in dispatchers.all_instances():
         if i.enabled and i.debug:
@@ -169,7 +171,7 @@ def do_hide_password(command):
         remote_dispatcher.options.log_file = None
 
 
-def complete_set_debug(line, text):
+def complete_set_debug(line: str, text: str) -> List[str]:
     if len(line[:-1].split()) >= 2:
         # Debug value already given in command line
         return complete_shells(line, text)
@@ -178,8 +180,7 @@ def complete_set_debug(line, text):
     return ['y ', 'n ']
 
 
-def do_set_debug(command):
-    assert isinstance(command, str)
+def do_set_debug(command: str) -> None:
     split = command.split()
     if not split:
         console_output(b'Expected at least a letter\n')
@@ -194,7 +195,7 @@ def do_set_debug(command):
         i.debug = debug
 
 
-def do_export_vars(command):
+def do_export_vars(command: str) -> None:
     rank = 0
     for shell in dispatchers.all_instances():
         if shell.enabled:
@@ -218,11 +219,11 @@ add_to_history('$POLYSH_RANK $POLYSH_NAME $POLYSH_DISPLAY_NAME')
 add_to_history('$POLYSH_NR_SHELLS')
 
 
-def complete_set_log(line, text):
+def complete_set_log(line: str, text: str) -> List[str]:
     return complete_local_path(text)
 
 
-def do_set_log(command):
+def do_set_log(command: str) -> None:
     command = command.strip()
     if command:
         try:
@@ -235,12 +236,12 @@ def do_set_log(command):
         console_output(b'Logging disabled\n')
 
 
-def complete_show_read_buffer(line, text):
+def complete_show_read_buffer(line: str, text: str) -> List[str]:
     return complete_shells(line, text, lambda i: i.read_buffer or
                            i.read_in_state_not_started)
 
 
-def do_show_read_buffer(command):
+def do_show_read_buffer(command: str) -> None:
     for i in selected_shells(command):
         if i.read_in_state_not_started:
             i.print_lines(i.read_in_state_not_started)
diff --git a/polysh/control_commands_helpers.py b/polysh/control_commands_helpers.py
index 75bbc4b..de71cd2 100644
--- a/polysh/control_commands_helpers.py
+++ b/polysh/control_commands_helpers.py
@@ -19,6 +19,7 @@ Copyright (c) 2018 InnoGames GmbH
 import os
 from fnmatch import fnmatch
 import readline
+from typing import Iterator, List, Set, Callable
 
 from polysh.host_syntax import expand_syntax
 from polysh.console import console_output
@@ -26,7 +27,7 @@ from polysh import dispatchers
 from polysh import remote_dispatcher
 
 
-def toggle_shells(command, enable):
+def toggle_shells(command: str, enable: bool) -> None:
     """Enable or disable the specified shells. If the command would have
     no effect, it changes all other shells to the inverse enable value."""
     selection = list(selected_shells(command))
@@ -42,14 +43,16 @@ def toggle_shells(command, enable):
             i.set_enabled(enable)
 
 
-def selected_shells(command):
+def selected_shells(
+    command: str
+) -> Iterator[remote_dispatcher.RemoteDispatcher]:
     """Iterator over the shells with names matching the patterns.
     An empty patterns matches all the shells"""
     if not command or command == '*':
         for i in dispatchers.all_instances():
             yield i
         return
-    selected = set()
+    selected = set()  # type: Set[remote_dispatcher.RemoteDispatcher]
     instance_found = False
     for pattern in command.split():
         found = False
@@ -65,7 +68,9 @@ def selected_shells(command):
             console_output('{} not found\n'.format(pattern).encode())
 
 
-def complete_shells(line, text, predicate=lambda i: True):
+def complete_shells(
+        line: str, text: str,
+        predicate: Callable = lambda i: True) -> List[str]:
     """Return the shell names to include in the completion"""
     res = [i.display_name + ' ' for i in dispatchers.all_instances() if
            i.display_name.startswith(text) and
@@ -74,22 +79,22 @@ def complete_shells(line, text, predicate=lambda i: True):
     return res
 
 
-def expand_local_path(path):
+def expand_local_path(path: str) -> str:
     return os.path.expanduser(os.path.expandvars(path) or '~')
 
 
-def list_control_commands():
+def list_control_commands() -> List[str]:
     from polysh import control_commands
     return [c[3:] for c in dir(control_commands) if c.startswith('do_')]
 
 
-def get_control_command(name):
+def get_control_command(name: str) -> Callable:
     from polysh import control_commands
     func = getattr(control_commands, 'do_' + name)
     return func
 
 
-def complete_control_command(line, text):
+def complete_control_command(line: str, text: str) -> List[str]:
     from polysh import control_commands
     if readline.get_begidx() == 0:
         # Completing control command name
@@ -100,14 +105,14 @@ def complete_control_command(line, text):
         # Completing control command parameters
         cmd = line.split()[0][1:]
 
-        def def_compl(line):
+        def def_compl(line: str) -> List:
             return []
         compl_func = getattr(control_commands, 'complete_' + cmd, def_compl)
         matches = compl_func(line, text)
     return matches
 
 
-def handle_control_command(line):
+def handle_control_command(line: str) -> None:
     if not line:
         return
     cmd_name = line.split()[0]
diff --git a/polysh/dispatchers.py b/polysh/dispatchers.py
index 8037b42..e0327ba 100644
--- a/polysh/dispatchers.py
+++ b/polysh/dispatchers.py
@@ -21,13 +21,15 @@ import fcntl
 import struct
 import sys
 import termios
+from typing import List
+from typing import Tuple
 
 from polysh import remote_dispatcher
 from polysh import display_names
 from polysh.terminal_size import terminal_size
 
 
-def _split_port(hostname):
+def _split_port(hostname: str) -> Tuple[str, str]:
     """ Splits a string(hostname, given by the user) into hostname and port,
     returns a tuple """
     s = hostname.split(':', 1)
@@ -37,14 +39,14 @@ def _split_port(hostname):
         return s[0], '22'
 
 
-def all_instances():
+def all_instances() -> List[remote_dispatcher.RemoteDispatcher]:
     """Iterator over all the remote_dispatcher instances"""
     return sorted([i for i in asyncore.socket_map.values() if
                    isinstance(i, remote_dispatcher.RemoteDispatcher)],
                   key=lambda i: i.display_name or '')
 
 
-def count_awaited_processes():
+def count_awaited_processes() -> Tuple[int, int]:
     """Return a tuple with the number of awaited processes and the total
     number"""
     awaited = 0
@@ -57,7 +59,7 @@ def count_awaited_processes():
     return awaited, total
 
 
-def all_terminated():
+def all_terminated() -> bool:
     """For each remote shell determine if its terminated"""
     instances_found = False
     for i in all_instances():
@@ -68,7 +70,7 @@ def all_terminated():
     return instances_found
 
 
-def update_terminal_size():
+def update_terminal_size() -> None:
     """Propagate the terminal size to the remote shells accounting for the
     place taken by the longest name"""
     w, h = terminal_size()
@@ -84,10 +86,9 @@ def update_terminal_size():
             fcntl.ioctl(i.fd, bug, packed_size)
 
 
-def format_info(info_list):
-    """Turn a 2-dimension list of bytes into a 1-dimension list of bytes with
-    correct spacing"""
-
+def format_info(info_list: List[List[bytes]]) -> List[bytes]:
+    """Turn a 2-dimension list of strings into a 1-dimension list of strings
+    with correct spacing"""
     max_lengths = []
     if info_list:
         nr_columns = len(info_list[0])
@@ -96,7 +97,7 @@ def format_info(info_list):
     for i in range(nr_columns):
         max_lengths.append(max([len(info[i]) for info in info_list]))
 
-    flattened_info_list = []
+    flattened_info_list = []  # type: List[bytes]
     for info_id in range(len(info_list)):
         info = info_list[info_id]
         for str_id in range(len(info) - 1):
@@ -110,7 +111,7 @@ def format_info(info_list):
     return flattened_info_list
 
 
-def create_remote_dispatchers(hosts):
+def create_remote_dispatchers(hosts: List[str]) -> None:
     last_message = ''
     for i, host in enumerate(hosts):
         if remote_dispatcher.options.interactive:
diff --git a/polysh/display_names.py b/polysh/display_names.py
index 35480e0..87696fb 100644
--- a/polysh/display_names.py
+++ b/polysh/display_names.py
@@ -16,6 +16,7 @@ Copyright (c) 2018 InnoGames GmbH
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+from typing import Dict, List, Optional
 from collections import defaultdict
 # The prefix is the key, the value is a list of booleans. A boolean at an
 # index is True if that index is currently in use.
@@ -23,13 +24,13 @@ PREFIXES = defaultdict(lambda: [])  # type: Dict[str, List[bool]]
 
 # dict with key:len(display_name) value:nr of enabled shells with a
 # display_name of such a length
-NR_ENABLED_DISPLAY_NAMES_BY_LENGTH = defaultdict(lambda: [])
+NR_ENABLED_DISPLAY_NAMES_BY_LENGTH = dict()  # type: Dict[int, int]
 
 # Used for terminal size and layout
 max_display_name_length = 0
 
 
-def acquire_prefix_index(prefix):
+def acquire_prefix_index(prefix: str) -> int:
     # Search and reuse removed host suffix
     for idx, item in enumerate(PREFIXES[prefix]):
         if not item:
@@ -41,7 +42,7 @@ def acquire_prefix_index(prefix):
     return len(PREFIXES[prefix]) - 1
 
 
-def release_prefix_index(prev_display_name):
+def release_prefix_index(prev_display_name: str) -> None:
     split = prev_display_name.split('#', 1)
     prefix = split[0]
     if len(split) == 1:
@@ -53,7 +54,7 @@ def release_prefix_index(prev_display_name):
     # to mark the current suffix index as unused.
     if suffix < len(PREFIXES[prefix]) - 1:
         PREFIXES[prefix][suffix] = False
-        return
+        return None
 
     # We are deleting the host with the highest suffix. Therefore we need to
     # delete it.
@@ -62,7 +63,7 @@ def release_prefix_index(prev_display_name):
     # Remove holes previously left.
     for idx, in_use in reversed(list(enumerate(PREFIXES[prefix]))):
         if in_use:
-            return
+            return None
         del PREFIXES[prefix][idx]
 
     # If we arrived here, we just deleted the last item with a specific
@@ -70,7 +71,7 @@ def release_prefix_index(prev_display_name):
     del PREFIXES[prefix]
 
 
-def make_unique_name(prefix):
+def make_unique_name(prefix: str) -> str:
     suffix = acquire_prefix_index(prefix)
     if suffix:
         return '{}#{}'.format(prefix, suffix)
@@ -78,7 +79,7 @@ def make_unique_name(prefix):
     return prefix
 
 
-def update_max_display_name_length():
+def update_max_display_name_length() -> None:
     from polysh.dispatchers import update_terminal_size
     new_max = max(NR_ENABLED_DISPLAY_NAMES_BY_LENGTH.keys(), default=0)
     global max_display_name_length
@@ -87,9 +88,10 @@ def update_max_display_name_length():
         update_terminal_size()
 
 
-def change(prev_display_name, new_prefix):
-    assert isinstance(prev_display_name, str) or prev_display_name is None
-    assert isinstance(new_prefix, str) or new_prefix is None
+def change(
+    prev_display_name: Optional[str],
+    new_prefix: Optional[str]
+) -> Optional[str]:
     if new_prefix and '#' in new_prefix:
         raise Exception('Names cannot contain #')
 
@@ -98,7 +100,7 @@ def change(prev_display_name, new_prefix):
             set_enabled(prev_display_name, False)
         release_prefix_index(prev_display_name)
         if new_prefix is None:
-            return
+            return None
 
     name = make_unique_name(new_prefix)
     set_enabled(name, True)
@@ -106,7 +108,7 @@ def change(prev_display_name, new_prefix):
     return name
 
 
-def set_enabled(display_name, enabled):
+def set_enabled(display_name: str, enabled: bool) -> None:
     length = len(display_name)
     if enabled:
         if length in NR_ENABLED_DISPLAY_NAMES_BY_LENGTH:
diff --git a/polysh/host_syntax.py b/polysh/host_syntax.py
index 4dfc9d3..40374dd 100644
--- a/polysh/host_syntax.py
+++ b/polysh/host_syntax.py
@@ -17,6 +17,8 @@ Copyright (c) 2018 InnoGames GmbH
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 import re
+from typing import Iterator
+from typing import Tuple
 
 # Currently the only expansion is <START_NUMBER-END_NUMBER>
 # <1-10> => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
@@ -29,14 +31,16 @@ import re
 syntax_pattern = re.compile('<([0-9,-]+)>')
 interval_pattern = re.compile('([0-9]+)(-[0-9]+)?')
 
-def _split_port(hostname):
+
+def _split_port(hostname: str) -> Tuple[str, str]:
     s = hostname.split(':', 1)
     if len(s) > 1:
         return s[0], s[1]
     else:
         return s[0], '22'
 
-def _iter_numbers(start, end):
+
+def _iter_numbers(start: str, end: str) -> Iterator[str]:
     int_start = int(start)
     int_end = int(end)
     if int_start < int_end:
@@ -54,7 +58,7 @@ def _iter_numbers(start, end):
         yield s
 
 
-def expand_syntax(string):
+def expand_syntax(string: str) -> Iterator[str]:
     """Iterator over all the strings in the expansion of the argument"""
     match = syntax_pattern.search(string)
     if match:
diff --git a/polysh/main.py b/polysh/main.py
index f3e7691..1143585 100644
--- a/polysh/main.py
+++ b/polysh/main.py
@@ -26,6 +26,7 @@ import signal
 import sys
 import termios
 import readline
+from typing import Callable, List
 
 from polysh import remote_dispatcher
 from polysh import dispatchers
@@ -36,7 +37,7 @@ from polysh import control_commands
 from polysh import VERSION
 
 
-def kill_all():
+def kill_all() -> None:
     """When polysh quits, we kill all the remote shells we started"""
     for i in dispatchers.all_instances():
         try:
@@ -46,7 +47,7 @@ def kill_all():
             pass
 
 
-def parse_cmdline():
+def parse_cmdline() -> argparse.Namespace:
     usage = '%s [OPTIONS] HOSTS...\n' % (sys.argv[0]) + \
             'Control commands are prefixed by ":".'
     parser = argparse.ArgumentParser(usage)
@@ -121,7 +122,7 @@ def parse_cmdline():
     return args
 
 
-def find_non_interactive_command(command):
+def find_non_interactive_command(command: str) -> str:
     if sys.stdin.isatty():
         return command
 
@@ -137,7 +138,7 @@ def find_non_interactive_command(command):
     return command or stdin
 
 
-def init_history(histfile):
+def init_history(histfile: str) -> None:
     if hasattr(readline, "read_history_file"):
         try:
             readline.read_history_file(histfile)
@@ -145,12 +146,12 @@ def init_history(histfile):
             pass
 
 
-def save_history(histfile):
+def save_history(histfile: str) -> None:
     readline.set_history_length(1000)
     readline.write_history_file(histfile)
 
 
-def loop(interactive):
+def loop(interactive: bool) -> None:
     histfile = os.path.expanduser("~/.polysh_history")
     init_history(histfile)
     next_signal = None
@@ -197,7 +198,7 @@ def loop(interactive):
             sys.exit(e.args[0])
 
 
-def _profile(continuation):
+def _profile(continuation: Callable) -> None:
     prof_file = 'polysh.prof'
     import cProfile
     import pstats
@@ -211,13 +212,13 @@ def _profile(continuation):
     os.remove(prof_file)
 
 
-def restore_tty_on_exit():
+def restore_tty_on_exit() -> None:
     fd = sys.stdin.fileno()
     old = termios.tcgetattr(fd)
     atexit.register(lambda: termios.tcsetattr(fd, termios.TCSADRAIN, old))
 
 
-def run():
+def run() -> None:
     """Launch polysh"""
     locale.setlocale(locale.LC_ALL, '')
     atexit.register(kill_all)
@@ -236,7 +237,7 @@ def run():
 
     remote_dispatcher.options = args
 
-    hosts = []
+    hosts = []  # type: List[str]
     for host in args.host_names:
         hosts.extend(expand_syntax(host))
 
@@ -248,7 +249,7 @@ def run():
     stdin.the_stdin_thread = stdin.StdinThread(args.interactive)
 
     if args.profile:
-        def safe_loop():
+        def safe_loop() -> None:
             try:
                 loop(args.interactive)
             except BaseException:
diff --git a/polysh/remote_dispatcher.py b/polysh/remote_dispatcher.py
index b9a27ae..360d245 100644
--- a/polysh/remote_dispatcher.py
+++ b/polysh/remote_dispatcher.py
@@ -24,6 +24,8 @@ import sys
 import termios
 import select
 import platform
+from typing import Optional, List
+from argparse import Namespace
 
 from polysh.buffered_dispatcher import BufferedDispatcher
 from polysh import callbacks
@@ -48,7 +50,7 @@ COLORS = [1] + list(range(30, 37))
 nr_handle_read = 0
 
 
-def main_loop_iteration(timeout=None):
+def main_loop_iteration(timeout: Optional[float] = None) -> int:
     """Return the number of RemoteDispatcher.handle_read() calls made by this
     iteration"""
     prev_nr_read = nr_handle_read
@@ -56,8 +58,7 @@ def main_loop_iteration(timeout=None):
     return nr_handle_read - prev_nr_read
 
 
-def log(msg):
-    assert isinstance(msg, bytes)
+def log(msg: bytes) -> None:
     if options.log_file:
         fd = options.log_file.fileno()
         while msg:
@@ -73,10 +74,7 @@ def log(msg):
 class RemoteDispatcher(BufferedDispatcher):
     """A RemoteDispatcher is a ssh process we communicate with"""
 
-    def __init__(self, hostname, port):
-        assert isinstance(hostname, str)
-        assert isinstance(port, str)
-
+    def __init__(self, hostname: str, port: str) -> None:
         if port != "22":
             port = "-p " + port
         else:
@@ -97,20 +95,19 @@ class RemoteDispatcher(BufferedDispatcher):
         self.enabled = True  # shells can be enabled and disabled
         self.state = STATE_NOT_STARTED
         self.term_size = (-1, -1)
-        self.display_name = None
+        self.display_name = None  # type: Optional[str]
         self.change_name(self.hostname.encode())
         self.init_string = self.configure_tty() + self.set_prompt()
         self.init_string_sent = False
         self.read_in_state_not_started = b''
         self.command = options.command
         self.last_printed_line = b''
+        self.color_code = None
         if sys.stdout.isatty() and not options.disable_color:
             COLORS.insert(0, COLORS.pop())  # Rotate the colors
             self.color_code = COLORS[0]
-        else:
-            self.color_code = None
 
-    def launch_ssh(self, name, port):
+    def launch_ssh(self, name: str, port: str) -> None:
         """Launch the ssh command in the child process"""
         if options.user:
             name = '%s@%s' % (options.user, name)
@@ -119,7 +116,7 @@ class RemoteDispatcher(BufferedDispatcher):
             evaluated = '%s %s' % (evaluated, name)
         os.execlp('/bin/sh', 'sh', '-c', evaluated)
 
-    def set_enabled(self, enabled):
+    def set_enabled(self, enabled: bool) -> None:
         if enabled != self.enabled and options.interactive:
             # In non-interactive mode, remote processes leave as soon
             # as they are terminated, but we don't want to break the
@@ -127,7 +124,7 @@ class RemoteDispatcher(BufferedDispatcher):
             display_names.set_enabled(self.display_name, enabled)
         self.enabled = enabled
 
-    def change_state(self, state):
+    def change_state(self, state: int) -> None:
         """Change the state of the remote process, logging the change"""
         if state is not self.state:
             if self.debug:
@@ -136,7 +133,7 @@ class RemoteDispatcher(BufferedDispatcher):
                 self.read_in_state_not_started = b''
             self.state = state
 
-    def disconnect(self):
+    def disconnect(self) -> None:
         """We are no more interested in this remote process"""
         try:
             os.kill(-self.pid, signal.SIGKILL)
@@ -153,16 +150,19 @@ class RemoteDispatcher(BufferedDispatcher):
             raise asyncore.ExitNow(1)
         self.change_state(STATE_DEAD)
 
-    def configure_tty(self):
+    def configure_tty(self) -> bytes:
         """We don't want \n to be replaced with \r\n, and we disable the echo"""
         attr = termios.tcgetattr(self.fd)
-        attr[1] &= ~termios.ONLCR  # oflag
-        attr[3] &= ~termios.ECHO  # lflag
+        # The following raises a mypy warning, as python type hints don't allow
+        # per list item granularity.  The last item in attr is List[bytes], but
+        # we don't access that here.
+        attr[1] &= ~termios.ONLCR  # type: ignore # oflag
+        attr[3] &= ~termios.ECHO  # type: ignore # lflag
         termios.tcsetattr(self.fd, termios.TCSANOW, attr)
         # unsetopt zle prevents Zsh from resetting the tty
         return b'unsetopt zle 2> /dev/null;stty -echo -onlcr -ctlecho;'
 
-    def seen_prompt_cb(self, unused):
+    def seen_prompt_cb(self, unused: str) -> None:
         if options.interactive:
             self.change_state(STATE_IDLE)
         elif self.command:
@@ -172,7 +172,7 @@ class RemoteDispatcher(BufferedDispatcher):
             self.dispatch_command(b'exit 2>/dev/null\n')
             self.command = None
 
-    def set_prompt(self):
+    def set_prompt(self) -> bytes:
         """The prompt is important because we detect the readyness of a process
         by waiting for its prompt."""
         # No right prompt
@@ -185,13 +185,13 @@ class RemoteDispatcher(BufferedDispatcher):
         command_line += b'PS1="' + prompt1 + b'""' + prompt2 + b'\n"\n'
         return command_line
 
-    def readable(self):
+    def readable(self) -> bool:
         """We are always interested in reading from active remote processes if
         the buffer is OK"""
         return (self.state != STATE_DEAD and
                 super().readable())
 
-    def handle_expt(self):
+    def handle_expt(self) -> None:
         # Dirty hack to ignore POLLPRI flag that is raised on Mac OS, but not
         # on linux. asyncore calls this method in case POLLPRI flag is set, but
         # self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR) == 0
@@ -200,7 +200,7 @@ class RemoteDispatcher(BufferedDispatcher):
 
         self.handle_close()
 
-    def handle_close(self):
+    def handle_close(self) -> None:
         if self.state is STATE_DEAD:
             # This connection has already been killed. Asyncore has probably
             # called handle_close() or handle_expt() on this connection twice.
@@ -216,8 +216,7 @@ class RemoteDispatcher(BufferedDispatcher):
         if self.temporary:
             self.close()
 
-    def print_lines(self, lines):
-        assert isinstance(lines, bytes)
+    def print_lines(self, lines: bytes) -> None:
         from polysh.display_names import max_display_name_length
         lines = lines.strip(b'\n')
         while True:
@@ -241,7 +240,7 @@ class RemoteDispatcher(BufferedDispatcher):
         console_output(console_data, logging_msg=log_data)
         self.last_printed_line = lines[lines.rfind(b'\n') + 1:]
 
-    def handle_read_fast_case(self, data):
+    def handle_read_fast_case(self, data: bytes) -> bool:
         """If we are in a fast case we'll avoid the long processing of each
         line"""
         if self.state is not STATE_RUNNING or callbacks.any_in(data):
@@ -256,7 +255,7 @@ class RemoteDispatcher(BufferedDispatcher):
         self.print_lines(data[:last_nl])
         return True
 
-    def handle_read(self):
+    def handle_read(self) -> None:
         """We got some output from a remote shell, this is one of the state
         machine"""
         if self.state == STATE_DEAD:
@@ -310,19 +309,19 @@ class RemoteDispatcher(BufferedDispatcher):
             self.dispatch_write(self.init_string)
             self.init_string_sent = True
 
-    def print_unfinished_line(self):
+    def print_unfinished_line(self) -> None:
         """The unfinished line stayed long enough in the buffer to be printed"""
         if self.state is STATE_RUNNING:
             if not callbacks.process(self.read_buffer):
                 self.print_lines(self.read_buffer)
             self.read_buffer = b''
 
-    def writable(self):
+    def writable(self) -> bool:
         """Do we want to write something?"""
         return (self.state != STATE_DEAD and
                 super().writable())
 
-    def handle_write(self):
+    def handle_write(self) -> None:
         """Let's write as much as we can"""
         num_sent = self.send(self.write_buffer)
         if self.debug:
@@ -330,32 +329,31 @@ class RemoteDispatcher(BufferedDispatcher):
                 self.print_debug(b'<== ' + self.write_buffer[:num_sent])
         self.write_buffer = self.write_buffer[num_sent:]
 
-    def print_debug(self, msg):
+    def print_debug(self, msg: bytes) -> None:
         """Log some debugging information to the console"""
-        assert isinstance(msg, bytes)
         state = STATE_NAMES[self.state].encode()
         console_output(b'[dbg] ' + self.display_name.encode() + b'[' + state +
                        b']: ' + msg + b'\n')
 
-    def get_info(self):
+    def get_info(self) -> List[bytes]:
         """Return a list with all information available about this process"""
         return [self.display_name.encode(),
                 self.enabled and b'enabled' or b'disabled',
                 STATE_NAMES[self.state].encode() + b':',
                 self.last_printed_line.strip()]
 
-    def dispatch_write(self, buf):
+    def dispatch_write(self, buf: bytes) -> bool:
         """There is new stuff to write when possible"""
         if self.state != STATE_DEAD and self.enabled:
             super().dispatch_write(buf)
             return True
         return False
 
-    def dispatch_command(self, command):
+    def dispatch_command(self, command: bytes) -> None:
         if self.dispatch_write(command):
             self.change_state(STATE_RUNNING)
 
-    def change_name(self, new_name):
+    def change_name(self, new_name: Optional[bytes]) -> None:
         """Change the name of the shell, possibly updating the maximum name
         length"""
         if not new_name:
@@ -365,7 +363,7 @@ class RemoteDispatcher(BufferedDispatcher):
         self.display_name = display_names.change(
             self.display_name, name)
 
-    def rename(self, name):
+    def rename(self, name: bytes) -> None:
         """Send to the remote shell, its new name to be shell expanded"""
         if name:
             # defug callback add?
@@ -376,6 +374,6 @@ class RemoteDispatcher(BufferedDispatcher):
         else:
             self.change_name(self.hostname.encode())
 
-    def close(self):
+    def close(self) -> None:
         display_names.change(self.display_name, None)
         super().close()
diff --git a/polysh/stdin.py b/polysh/stdin.py
index 984f0b4..d448542 100644
--- a/polysh/stdin.py
+++ b/polysh/stdin.py
@@ -31,6 +31,7 @@ from threading import Thread, Event, Lock
 from polysh import dispatchers, remote_dispatcher
 from polysh.console import console_output, set_last_status_length
 from polysh import completion
+from typing import Optional
 
 the_stdin_thread = None  # type: StdinThread
 
@@ -38,17 +39,16 @@ the_stdin_thread = None  # type: StdinThread
 class InputBuffer(object):
     """The shared input buffer between the main thread and the stdin thread"""
 
-    def __init__(self):
+    def __init__(self) -> None:
         self.lock = Lock()
         self.buf = b''
 
-    def add(self, data):
+    def add(self, data: bytes) -> None:
         """Add data to the buffer"""
-        assert isinstance(data, bytes)
         with self.lock:
             self.buf += data
 
-    def get(self):
+    def get(self) -> bytes:
         """Get the content of the buffer"""
         data = b''
         with self.lock:
@@ -57,7 +57,7 @@ class InputBuffer(object):
         return data
 
 
-def process_input_buffer():
+def process_input_buffer() -> None:
     """Send the content of the input buffer to all remote processes, this must
     be called in the main thread"""
     from polysh.control_commands_helpers import handle_control_command
@@ -115,17 +115,16 @@ def process_input_buffer():
 class SocketNotificationReader(asyncore.dispatcher):
     """The socket reader in the main thread"""
 
-    def __init__(self, the_stdin_thread):
+    def __init__(self, the_stdin_thread: 'StdinThread') -> None:
         asyncore.dispatcher.__init__(self, the_stdin_thread.socket_read)
 
-    def _do(self, c):
-        assert isinstance(c, bytes)
+    def _do(self, c: bytes) -> None:
         if c == b'd':
             process_input_buffer()
         else:
             raise Exception('Unknown code: %s' % (c))
 
-    def handle_read(self):
+    def handle_read(self) -> None:
         """Handle all the available character commands in the socket"""
         while True:
             try:
@@ -141,12 +140,12 @@ class SocketNotificationReader(asyncore.dispatcher):
                 self.send(b'A')
                 self.socket.setblocking(False)
 
-    def writable(self):
+    def writable(self) -> bool:
         """Our writes are blocking"""
         return False
 
 
-def write_main_socket(c):
+def write_main_socket(c: bytes) -> None:
     """Synchronous write to the main socket, wait for ACK"""
     the_stdin_thread.socket_write.send(c)
     while True:
@@ -169,7 +168,7 @@ os.remove(tempfile_name)
 os.write(tempfile_fd, b'\x03')
 
 
-def get_stdin_pid(cached_result=None):
+def get_stdin_pid(cached_result: Optional[int] = None) -> int:
     """Try to get the PID of the stdin thread, otherwise get the whole process
     ID"""
     if cached_result is None:
@@ -186,7 +185,7 @@ def get_stdin_pid(cached_result=None):
     return cached_result
 
 
-def interrupt_stdin_thread():
+def interrupt_stdin_thread() -> None:
     """The stdin thread may be in raw_input(), get out of it"""
     dupped_stdin = os.dup(0)  # Backup the stdin fd
     assert not the_stdin_thread.interrupt_asked  # Sanity check
@@ -204,15 +203,18 @@ def interrupt_stdin_thread():
 echo_enabled = True
 
 
-def set_echo(echo):
+def set_echo(echo: bool) -> None:
     global echo_enabled
     if echo != echo_enabled:
         fd = sys.stdin.fileno()
         attr = termios.tcgetattr(fd)
+        # The following raises a mypy warning, as python type hints don't allow
+        # per list item granularity.  The last item in attr is List[bytes], but
+        # we don't access that here.
         if echo:
-            attr[3] |= termios.ECHO
+            attr[3] |= termios.ECHO  # type: ignore
         else:
-            attr[3] &= ~termios.ECHO
+            attr[3] &= ~termios.ECHO  # type: ignore
         termios.tcsetattr(fd, termios.TCSANOW, attr)
         echo_enabled = echo
 
@@ -220,7 +222,7 @@ def set_echo(echo):
 class StdinThread(Thread):
     """The stdin thread, used to call raw_input()"""
 
-    def __init__(self, interactive):
+    def __init__(self, interactive: bool) -> None:
         Thread.__init__(self, name='stdin thread')
         completion.install_completion_handler()
         self.input_buffer = InputBuffer()
@@ -239,13 +241,13 @@ class StdinThread(Thread):
             self.prepend_text = None  # type: Optional[str]
             readline.set_pre_input_hook(self.prepend_previous_text)
 
-    def prepend_previous_text(self):
+    def prepend_previous_text(self) -> None:
         if self.prepend_text:
             readline.insert_text(self.prepend_text)
             readline.redisplay()
             self.prepend_text = None
 
-    def want_raw_input(self):
+    def want_raw_input(self) -> None:
         nr, total = dispatchers.count_awaited_processes()
         if nr:
             prompt = 'waiting (%d/%d)> ' % (nr, total)
@@ -259,12 +261,12 @@ class StdinThread(Thread):
             self.in_raw_input.wait(0.1)
         self.raw_input_wanted.clear()
 
-    def no_raw_input(self):
+    def no_raw_input(self) -> None:
         if not self.out_of_raw_input.is_set():
             interrupt_stdin_thread()
 
     # Beware of races
-    def run(self):
+    def run(self) -> None:
         while True:
             self.raw_input_wanted.wait()
             self.out_of_raw_input.set()
diff --git a/polysh/terminal_size.py b/polysh/terminal_size.py
index 0f181a0..662904b 100644
--- a/polysh/terminal_size.py
+++ b/polysh/terminal_size.py
@@ -32,20 +32,21 @@ Copyright (c) 2018 InnoGames GmbH
 
 
 import os
+from typing import Tuple, Optional
 
 
-def _ioctl_GWINSZ(fd):  # TABULATION FUNCTIONS
+def _ioctl_GWINSZ(fd: int) -> Optional[Tuple[int, int]]:
     try:  # Discover terminal width
         import fcntl
         import termios
         import struct
         cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, b'1234'))
     except BaseException:
-        return
-    return cr
+        return None
+    return int(cr[0]), int(cr[1])
 
 
-def terminal_size():  # decide on *some* terminal size
+def terminal_size() -> Tuple[int, int]:  # decide on *some* terminal size
     """Return (lines, columns)."""
     cr = _ioctl_GWINSZ(0) or _ioctl_GWINSZ(
         1) or _ioctl_GWINSZ(2)  # try open fds
@@ -58,7 +59,7 @@ def terminal_size():  # decide on *some* terminal size
             pass
         if not cr:                            # env vars or finally defaults
             try:
-                cr = os.environ['LINES'], os.environ['COLUMNS']
+                cr = int(os.environ['LINES']), int(os.environ['COLUMNS'])
             except BaseException:
                 cr = 25, 80
-    return int(cr[1]), int(cr[0])         # reverse rows, cols
+    return cr[1], cr[0]         # reverse rows, cols
diff --git a/setup.py b/setup.py
index cf6d53d..983138e 100755
--- a/setup.py
+++ b/setup.py
@@ -22,8 +22,8 @@ from os import path
 from sys import exit, version_info as PYTHON_VERSION
 from polysh import VERSION as POLYSH_VERSION
 
-if PYTHON_VERSION < (3, 4):
-    print('Aborting polysh installation! Polysh requires python 3.4 or later.')
+if PYTHON_VERSION < (3, 5):
+    print('Aborting polysh installation! Polysh requires python 3.5 or later.')
     exit(1)
 
 # Get the long description from the README file
@@ -60,11 +60,10 @@ setup(
         # This does not influence pip when choosing what to install. It is used
         # for the package list on the pypi website.
         'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.4',
         'Programming Language :: Python :: 3.5',
         'Programming Language :: Python :: 3.6',
     ],
-    python_requires='>=3.4',
+    python_requires='>=3.5',
 
     packages=['polysh'],
     entry_points={
